/**
 * Malware - Understanding Malicious Software
 *
 * Malware (malicious software) refers to any software designed to harm,
 * exploit, or take unauthorized control of computer systems. It encompasses
 * viruses, worms, Trojans, spyware, ransomware, and more. Understanding
 * malware is essential for security testing and defense.
 *
 * Key Concepts:
 * - Types: viruses, worms, Trojans, ransomware, spyware
 * - Spread methods: email, downloads, social engineering
 * - Attack vectors: data theft, system control, encryption
 * - Detection and prevention strategies
 */

/**
 * MalwareSignature represents a known malware identifier.
 * Used for signature-based detection.
 */
class MalwareSignature {
    constructor(options) {
        this.id = options.id;
        this.name = options.name;
        this.type = options.type;
        this.hash = options.hash; // File hash (MD5, SHA256)
        this.pattern = options.pattern; // Byte pattern or regex
        this.severity = options.severity || 'medium';
        this.description = options.description;
        this.firstSeen = options.firstSeen;
        this.lastUpdated = new Date();
    }

    /**
     * Checks if data matches this signature
     * @param {string} data - Data to check (hash or content)
     * @param {string} checkType - Type of check (hash or pattern)
     * @returns {boolean} True if matches
     */
    matches(data, checkType = 'hash') {
        if (checkType === 'hash') {
            return data === this.hash;
        }

        if (checkType === 'pattern' && this.pattern) {
            const regex = new RegExp(this.pattern, 'i');
            return regex.test(data);
        }

        return false;
    }

    /**
     * Gets signature summary
     * @returns {Object} Summary
     */
    getSummary() {
        return {
            id: this.id,
            name: this.name,
            type: this.type,
            severity: this.severity
        };
    }
}

/**
 * MalwareType represents a category of malware.
 * Contains characteristics and behavior patterns.
 */
class MalwareType {
    static types = {
        virus: {
            name: 'Virus',
            description: 'Self-replicating code that attaches to other programs',
            characteristics: [
                'Requires host program to execute',
                'Spreads by infecting other files',
                'Can remain dormant until triggered'
            ],
            indicators: ['File size changes', 'Unexpected program behavior', 'Corrupted files']
        },
        worm: {
            name: 'Worm',
            description: 'Self-replicating malware that spreads across networks',
            characteristics: [
                'Self-contained, no host needed',
                'Spreads through network vulnerabilities',
                'Can consume bandwidth and resources'
            ],
            indicators: ['Network slowdown', 'High CPU usage', 'Unexpected network traffic']
        },
        trojan: {
            name: 'Trojan',
            description: 'Malware disguised as legitimate software',
            characteristics: [
                'Appears as useful application',
                'Requires user to execute',
                'Creates backdoors for attackers'
            ],
            indicators: ['Unexpected processes', 'Strange network connections', 'System changes']
        },
        ransomware: {
            name: 'Ransomware',
            description: 'Encrypts files and demands payment for decryption',
            characteristics: [
                'Encrypts user files',
                'Displays ransom demand',
                'May have time-limited threats'
            ],
            indicators: ['Encrypted files', 'Ransom notes', 'Inaccessible documents']
        },
        spyware: {
            name: 'Spyware',
            description: 'Covertly collects information about users',
            characteristics: [
                'Runs hidden in background',
                'Captures keystrokes, screenshots',
                'Transmits data to attacker'
            ],
            indicators: ['Slow system', 'Browser changes', 'Unknown processes']
        },
        adware: {
            name: 'Adware',
            description: 'Displays unwanted advertisements',
            characteristics: [
                'Shows pop-up ads',
                'May track browsing habits',
                'Often bundled with free software'
            ],
            indicators: ['Pop-up ads', 'Browser redirects', 'Slow browsing']
        },
        rootkit: {
            name: 'Rootkit',
            description: 'Hides malware presence at system level',
            characteristics: [
                'Modifies operating system',
                'Hides files and processes',
                'Difficult to detect and remove'
            ],
            indicators: ['System instability', 'Security tool failures', 'Hidden processes']
        }
    };

    /**
     * Gets information about a malware type
     * @param {string} type - Type name
     * @returns {Object} Type information
     */
    static getInfo(type) {
        return this.types[type.toLowerCase()];
    }

    /**
     * Gets all malware types
     * @returns {Object} All types
     */
    static getAll() {
        return this.types;
    }

    /**
     * Gets types by characteristic
     * @param {string} keyword - Characteristic keyword
     * @returns {Array} Matching types
     */
    static searchByCharacteristic(keyword) {
        const lower = keyword.toLowerCase();
        return Object.entries(this.types)
            .filter(([_, info]) =>
                info.characteristics.some(c => c.toLowerCase().includes(lower)) ||
                info.description.toLowerCase().includes(lower)
            )
            .map(([key, info]) => ({ type: key, ...info }));
    }
}

/**
 * ThreatIndicator represents an Indicator of Compromise (IoC).
 * Used for threat intelligence and detection.
 */
class ThreatIndicator {
    constructor(options) {
        this.type = options.type; // hash, ip, domain, url, email
        this.value = options.value;
        this.malwareFamily = options.malwareFamily;
        this.confidence = options.confidence || 'medium';
        this.source = options.source;
        this.firstSeen = options.firstSeen;
        this.tags = options.tags || [];
    }

    /**
     * Checks if a value matches this indicator
     * @param {string} checkValue - Value to check
     * @returns {boolean} True if matches
     */
    matches(checkValue) {
        if (this.type === 'domain') {
            return checkValue.toLowerCase().includes(this.value.toLowerCase());
        }
        return checkValue === this.value;
    }

    /**
     * Gets indicator summary
     * @returns {Object} Summary
     */
    getSummary() {
        return {
            type: this.type,
            value: this.value,
            malwareFamily: this.malwareFamily,
            confidence: this.confidence
        };
    }
}

/**
 * MalwareScanner simulates malware detection.
 * Uses signature-based and heuristic detection.
 */
class MalwareScanner {
    constructor() {
        this.signatures = new Map();
        this.indicators = [];
        this.scanResults = [];
        this.loadSampleSignatures();
    }

    /**
     * Loads sample signatures for demonstration
     */
    loadSampleSignatures() {
        // Note: These are fictional signatures for educational purposes
        const sampleSignatures = [
            {
                id: 'SIG-001',
                name: 'TestVirus.A',
                type: 'virus',
                hash: 'a1b2c3d4e5f6g7h8i9j0',
                pattern: 'MALICIOUS_PATTERN',
                severity: 'high'
            },
            {
                id: 'SIG-002',
                name: 'TrojanDownloader.B',
                type: 'trojan',
                hash: 'z9y8x7w6v5u4t3s2r1q0',
                pattern: 'TROJAN_DOWNLOAD',
                severity: 'critical'
            }
        ];

        for (const sig of sampleSignatures) {
            this.signatures.set(sig.id, new MalwareSignature(sig));
        }
    }

    /**
     * Adds a signature to the scanner
     * @param {MalwareSignature} signature - Signature to add
     */
    addSignature(signature) {
        this.signatures.set(signature.id, signature);
    }

    /**
     * Adds a threat indicator
     * @param {ThreatIndicator} indicator - Indicator to add
     */
    addIndicator(indicator) {
        this.indicators.push(indicator);
    }

    /**
     * Scans a file (simulated)
     * @param {Object} file - File to scan
     * @returns {Object} Scan result
     */
    scanFile(file) {
        console.log(`Scanning: ${file.name}`);
        const startTime = Date.now();
        const threats = [];

        // Check against signatures (hash-based)
        for (const signature of this.signatures.values()) {
            if (signature.matches(file.hash, 'hash')) {
                threats.push({
                    type: 'signature_match',
                    signature: signature.getSummary(),
                    confidence: 'high'
                });
            }
        }

        // Check content patterns (heuristic)
        if (file.content) {
            for (const signature of this.signatures.values()) {
                if (signature.matches(file.content, 'pattern')) {
                    threats.push({
                        type: 'pattern_match',
                        signature: signature.getSummary(),
                        confidence: 'medium'
                    });
                }
            }
        }

        // Behavioral analysis (simulated)
        const behavioralThreats = this.behavioralAnalysis(file);
        threats.push(...behavioralThreats);

        const result = {
            file: file.name,
            hash: file.hash,
            scannedAt: new Date().toISOString(),
            scanDuration: Date.now() - startTime,
            clean: threats.length === 0,
            threatCount: threats.length,
            threats
        };

        this.scanResults.push(result);
        return result;
    }

    /**
     * Performs behavioral analysis (simulated)
     * @param {Object} file - File to analyze
     * @returns {Array} Detected threats
     */
    behavioralAnalysis(file) {
        const threats = [];
        const suspiciousBehaviors = [
            { pattern: /eval\s*\(/, type: 'code_execution', risk: 'high' },
            { pattern: /exec\s*\(/, type: 'command_execution', risk: 'high' },
            { pattern: /base64_decode/, type: 'obfuscation', risk: 'medium' },
            { pattern: /socket|connect/, type: 'network_activity', risk: 'medium' }
        ];

        if (file.content) {
            for (const behavior of suspiciousBehaviors) {
                if (behavior.pattern.test(file.content)) {
                    threats.push({
                        type: 'behavioral',
                        behavior: behavior.type,
                        risk: behavior.risk,
                        confidence: 'medium'
                    });
                }
            }
        }

        return threats;
    }

    /**
     * Checks an indicator against known threats
     * @param {string} type - Indicator type
     * @param {string} value - Value to check
     * @returns {Array} Matching indicators
     */
    checkIndicator(type, value) {
        return this.indicators
            .filter(i => i.type === type && i.matches(value))
            .map(i => i.getSummary());
    }

    /**
     * Gets scan statistics
     * @returns {Object} Statistics
     */
    getStatistics() {
        const infected = this.scanResults.filter(r => !r.clean).length;

        return {
            totalScans: this.scanResults.length,
            clean: this.scanResults.length - infected,
            infected,
            signatureCount: this.signatures.size,
            indicatorCount: this.indicators.length
        };
    }
}

/**
 * MalwareDefense provides defense strategies and recommendations.
 */
class MalwareDefense {
    static strategies = {
        prevention: [
            'Keep software and systems updated',
            'Use reputable antivirus software',
            'Enable firewalls',
            'Be cautious with email attachments',
            'Download software from official sources',
            'Use strong, unique passwords',
            'Enable two-factor authentication',
            'Educate users about phishing'
        ],
        detection: [
            'Monitor system for unusual activity',
            'Use intrusion detection systems',
            'Analyze network traffic',
            'Check file integrity regularly',
            'Review logs for anomalies',
            'Implement endpoint detection and response'
        ],
        response: [
            'Isolate affected systems',
            'Identify the malware type',
            'Remove the malware',
            'Restore from clean backups',
            'Change compromised credentials',
            'Report to appropriate authorities',
            'Document the incident',
            'Update defenses based on lessons learned'
        ]
    };

    /**
     * Gets defense recommendations for a malware type
     * @param {string} malwareType - Type of malware
     * @returns {Object} Recommendations
     */
    static getRecommendations(malwareType) {
        const typeInfo = MalwareType.getInfo(malwareType);

        const specific = {
            virus: ['Scan all files before opening', 'Disable autorun'],
            worm: ['Patch network vulnerabilities', 'Segment networks'],
            trojan: ['Verify software sources', 'Check digital signatures'],
            ransomware: ['Maintain offline backups', 'Never pay ransom'],
            spyware: ['Use anti-spyware tools', 'Monitor outbound traffic'],
            rootkit: ['Use rootkit scanners', 'Boot from clean media to scan']
        };

        return {
            malwareType,
            description: typeInfo?.description || 'Unknown type',
            generalPrevention: this.strategies.prevention,
            specificMeasures: specific[malwareType] || [],
            detection: this.strategies.detection,
            response: this.strategies.response
        };
    }

    /**
     * Gets all defense strategies
     * @returns {Object} All strategies
     */
    static getAll() {
        return this.strategies;
    }
}

// Demonstration
console.log('=== Malware Understanding Demo ===\n');

// Malware types
console.log('--- Malware Types ---');
const ransomwareInfo = MalwareType.getInfo('ransomware');
console.log('Ransomware:', ransomwareInfo);

console.log('\nTypes that spread via networks:');
MalwareType.searchByCharacteristic('network').forEach(t => {
    console.log(`  ${t.name}: ${t.description}`);
});

// Scanner demonstration
console.log('\n--- Malware Scanner Demo ---');
const scanner = new MalwareScanner();

// Add threat indicators
scanner.addIndicator(new ThreatIndicator({
    type: 'domain',
    value: 'malicious-domain.com',
    malwareFamily: 'BotnetX',
    confidence: 'high',
    source: 'ThreatFeed'
}));

// Scan files (simulated)
const cleanFile = {
    name: 'document.pdf',
    hash: 'clean1234567890',
    content: 'Normal document content'
};

const suspiciousFile = {
    name: 'suspicious.js',
    hash: 'suspicious123',
    content: 'eval(base64_decode("malicious code"))'
};

console.log('\nScan Results:');
console.log('Clean file:', scanner.scanFile(cleanFile));
console.log('Suspicious file:', scanner.scanFile(suspiciousFile));

// Check indicators
console.log('\n--- Indicator Check ---');
console.log('Domain check:',
    scanner.checkIndicator('domain', 'malicious-domain.com'));

// Statistics
console.log('\n--- Scanner Statistics ---');
console.log(scanner.getStatistics());

// Defense recommendations
console.log('\n--- Defense Recommendations ---');
const ransomwareDefense = MalwareDefense.getRecommendations('ransomware');
console.log('Ransomware Defense:');
console.log('  Specific measures:', ransomwareDefense.specificMeasures);
console.log('  Response steps:', ransomwareDefense.response.slice(0, 3));

/**
 * Best Practices for Malware Defense:
 *
 * 1. Keep all software updated with security patches
 * 2. Use layered security (defense in depth)
 * 3. Implement least privilege access
 * 4. Train users to recognize threats
 * 5. Maintain regular, tested backups
 * 6. Monitor systems for anomalies
 * 7. Have an incident response plan
 * 8. Use threat intelligence feeds
 * 9. Segment networks to limit spread
 * 10. Regularly test security controls
 */
